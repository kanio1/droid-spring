package com.droid.bss.infrastructure.event.handlers;

import com.droid.bss.infrastructure.event.publisher.DomainEvent;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.cloudevents.CloudEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.messaging.handler.annotation.Payload;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Handler for processing CloudEvents from Kafka.
 *
 * Deserializes CloudEvents and dispatches them to appropriate handlers.
 *
 * @since 1.0
 */
public class CloudEventHandler {

    private static final Logger log = LoggerFactory.getLogger(CloudEventHandler.class);

    private final EventHandlerRegistry registry;
    private final ObjectMapper objectMapper;
    private final Executor executor;
    private final boolean autoAcknowledge;

    /**
     * Creates a new CloudEventHandler.
     *
     * @param registry the event handler registry
     * @param objectMapper the JSON object mapper
     * @param executor the executor for async processing
     * @param autoAcknowledge whether to automatically acknowledge messages
     */
    public CloudEventHandler(EventHandlerRegistry registry, ObjectMapper objectMapper,
                             Executor executor, boolean autoAcknowledge) {
        this.registry = registry;
        this.objectMapper = objectMapper;
        this.executor = executor;
        this.autoAcknowledge = autoAcknowledge;
    }

    /**
     * Creates a new CloudEventHandler with auto-acknowledge enabled.
     *
     * @param registry the event handler registry
     * @param objectMapper the JSON object mapper
     * @param executor the executor for async processing
     */
    public CloudEventHandler(EventHandlerRegistry registry, ObjectMapper objectMapper, Executor executor) {
        this(registry, objectMapper, executor, true);
    }

    /**
     * Handles a single CloudEvent.
     *
     * @param cloudEvent the CloudEvent to handle
     * @param acknowledgment the Kafka acknowledgment (optional)
     * @return the list of handling results
     */
    public List<EventHandlingResult> handleCloudEvent(CloudEvent cloudEvent, Acknowledgment acknowledgment) {
        if (cloudEvent == null) {
            log.warn("Received null CloudEvent");
            if (acknowledgment != null && autoAcknowledge) {
                acknowledgment.acknowledge();
            }
            return Collections.emptyList();
        }

        String eventId = cloudEvent.getId();
        String eventType = cloudEvent.getType();
        log.debug("Processing CloudEvent: id={}, type={}", eventId, eventType);

        try {
            // Convert CloudEvent to DomainEvent
            DomainEvent domainEvent = convertToDomainEvent(cloudEvent);

            // Find handlers
            List<EventHandler<? extends DomainEvent>> handlers = registry.findHandlers(domainEvent);

            if (handlers.isEmpty()) {
                log.warn("No handlers found for event type: {}", eventType);
                if (acknowledgment != null && autoAcknowledge) {
                    acknowledgment.acknowledge();
                }
                return Collections.emptyList();
            }

            // Execute handlers
            List<EventHandlingResult> results = new ArrayList<>();
            for (EventHandler<? extends DomainEvent> handler : handlers) {
                try {
                    EventHandlingResult result = executeHandler(handler, domainEvent);
                    results.add(result);

                    if (!result.isSuccess()) {
                        log.warn("Handler {} failed for event {}: {}",
                            handler.getName(), eventId, result.getMessage());
                    }

                } catch (Exception e) {
                    log.error("Error executing handler {} for event {}",
                        handler.getName(), eventId, e);
                    results.add(EventHandlingResult.failure(
                        eventId,
                        eventType,
                        handler.getName(),
                        e.getMessage(),
                        0
                    ));
                }
            }

            if (acknowledgment != null && autoAcknowledge) {
                acknowledgment.acknowledge();
            }

            log.debug("Processed CloudEvent: id={}, handlers={}, results={}",
                eventId, handlers.size(), results.size());

            return results;

        } catch (Exception e) {
            log.error("Error processing CloudEvent: id={}, type={}, error={}",
                eventId, eventType, e.getMessage(), e);

            if (acknowledgment != null && autoAcknowledge) {
                acknowledgment.acknowledge();
            }

            // Return a single failure result
            EventHandlingResult errorResult = EventHandlingResult.failure(
                eventId,
                eventType,
                "CloudEventHandler",
                "Failed to process CloudEvent: " + e.getMessage(),
                0
            );

            return Collections.singletonList(errorResult);
        }
    }

    /**
     * Handles a single CloudEvent asynchronously.
     *
     * @param cloudEvent the CloudEvent to handle
     * @param acknowledgment the Kafka acknowledgment (optional)
     * @return the CompletableFuture with handling results
     */
    public CompletableFuture<List<EventHandlingResult>> handleCloudEventAsync(CloudEvent cloudEvent,
                                                                                Acknowledgment acknowledgment) {
        return CompletableFuture.supplyAsync(() -> handleCloudEvent(cloudEvent, acknowledgment), executor);
    }

    /**
     * Handles multiple CloudEvents.
     *
     * @param cloudEvents the CloudEvents to handle
     * @param acknowledgment the Kafka acknowledgment (optional)
     * @return the list of lists of handling results
     */
    public List<List<EventHandlingResult>> handleCloudEvents(List<CloudEvent> cloudEvents,
                                                              Acknowledgment acknowledgment) {
        if (cloudEvents == null || cloudEvents.isEmpty()) {
            return Collections.emptyList();
        }

        List<List<EventHandlingResult>> allResults = new ArrayList<>();

        for (CloudEvent cloudEvent : cloudEvents) {
            List<EventHandlingResult> results = handleCloudEvent(cloudEvent, acknowledgment);
            allResults.add(results);
        }

        return allResults;
    }

    /**
     * Handles multiple CloudEvents asynchronously.
     *
     * @param cloudEvents the CloudEvents to handle
     * @param acknowledgment the Kafka acknowledgment (optional)
     * @return the CompletableFuture with handling results
     */
    public CompletableFuture<List<List<EventHandlingResult>>> handleCloudEventsAsync(List<CloudEvent> cloudEvents,
                                                                                      Acknowledgment acknowledgment) {
        return CompletableFuture.supplyAsync(() -> handleCloudEvents(cloudEvents, acknowledgment), executor);
    }

    // Private helper methods

    @SuppressWarnings("unchecked")
    private <T extends DomainEvent> EventHandlingResult executeHandler(EventHandler<T> handler, DomainEvent event) {
        long startTime = System.currentTimeMillis();

        try {
            if (!handler.canHandle(event)) {
                return EventHandlingResult.failure(
                    event.getId(),
                    event.getType(),
                    handler.getName(),
                    "Handler cannot handle this event type",
                    0
                );
            }

            if (!handler.isEnabled()) {
                return EventHandlingResult.failure(
                    event.getId(),
                    event.getType(),
                    handler.getName(),
                    "Handler is disabled",
                    0
                );
            }

            // Execute handler
            EventHandlingResult result = handler.handle((T) event);

            long processingTime = System.currentTimeMillis() - startTime;

            // If result doesn't have processing time, set it
            if (result.getProcessingTimeMs() == 0) {
                result = EventHandlingResult.builder()
                    .success(result.isSuccess())
                    .eventId(result.getEventId())
                    .eventType(result.getEventType())
                    .handlerName(result.getHandlerName())
                    .message(result.getMessage())
                    .processedAt(result.getProcessedAt())
                    .processingTimeMs(processingTime)
                    .retryCount(result.getRetryCount())
                    .build();
            }

            return result;

        } catch (Exception e) {
            log.error("Handler {} threw exception for event {}", handler.getName(), event.getId(), e);

            long processingTime = System.currentTimeMillis() - startTime;

            return EventHandlingResult.failure(
                event.getId(),
                event.getType(),
                handler.getName(),
                e.getMessage(),
                processingTime
            );
        }
    }

    private DomainEvent convertToDomainEvent(CloudEvent cloudEvent) {
        try {
            // Create a simple DomainEvent from CloudEvent
            // In a real implementation, this would deserialize to the actual event class
            return new CloudEventWrapper(cloudEvent);

        } catch (Exception e) {
            throw EventHandlingException.deserializationFailure(
                cloudEvent.getId(),
                cloudEvent.getType(),
                e.getMessage()
            );
        }
    }

    /**
     * Wrapper class to convert CloudEvent to DomainEvent.
     */
    private static class CloudEventWrapper implements DomainEvent {
        private final CloudEvent cloudEvent;

        CloudEventWrapper(CloudEvent cloudEvent) {
            this.cloudEvent = cloudEvent;
        }

        @Override
        public String getId() {
            return cloudEvent.getId();
        }

        @Override
        public String getType() {
            return cloudEvent.getType();
        }

        @Override
        public String getSource() {
            return cloudEvent.getSource().toString();
        }

        @Override
        public Instant getTime() {
            return cloudEvent.getTime() != null ?
                cloudEvent.getTime().toInstant() :
                Instant.now();
        }

        @Override
        public String getSchemaUrl() {
            return cloudEvent.getSchemaUrl();
        }

        @Override
        public String getSubject() {
            return cloudEvent.getSubject();
        }

        @Override
        public String getPartitionKey() {
            String partitionKey = cloudEvent.getExtension("partitionKey");
            return partitionKey != null ? String.valueOf(partitionKey) : null;
        }
    }
}
