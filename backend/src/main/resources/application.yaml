spring:
  application:
    name: bss-backend
  datasource:
    url: jdbc:postgresql://${POSTGRES_HOST:localhost}:${POSTGRES_PORT:6432}/${POSTGRES_DB:bss}?sslmode=${DB_SSL_MODE:require}&ssl=true
    username: ${POSTGRES_USER:bss_app}
    password: ${POSTGRES_PASSWORD:placeholder_password}
    driver-class-name: org.postgresql.Driver
    hikari:
      # PgBouncer optimization settings
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: ${DB_MIN_IDLE:5}
      idle-timeout: 300000
      connection-timeout: 20000
      max-lifetime: 1200000
      leak-detection-threshold: 60000
      pool-name: bss-hikari-pool
      # Transaction pooling mode
      data-source-properties:
        prepareThreshold: 1
        # SSL/TLS Configuration
        ssl: ${DB_SSL_ENABLED:true}
        sslmode: ${DB_SSL_MODE:require}
        sslrootcert: ${DB_SSL_ROOTCERT:/etc/ssl/certs/ca-cert.pem}
        sslcert: ${DB_SSL_CERT:}
        sslkey: ${DB_SSL_KEY:}
        sslcrl: ${DB_SSL_CRL:}
        sslcompression: ${DB_SSL_COMPRESSION:0}
        sslpassword: ${DB_SSL_PASSWORD:}
        sslcallback: ${DB_SSL_CALLBACK:}
        sslpasswordcallback: ${DB_SSL_PASSWORD_CALLBACK:}
        cachePrepStmts: true
        prepStmtCacheSize: 250
        prepStmtCacheSqlLimit: 2048
        useServerPrepStmts: true
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        # PgBouncer transaction mode compatibility
        jdbc:
          batch_size: 20
          order_inserts: true
          order_updates: true
    defer-datasource-initialization: false
  flyway:
    locations: classpath:db/migration
    enabled: true
    baseline-on-migrate: true

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:#{null}}
      timeout: 2000ms
      ssl:
        enabled: ${REDIS_SSL_ENABLED:true}
        keystore:
          location: ${REDIS_SSL_KEYSTORE:#{null}}
          password: ${REDIS_SSL_KEYSTORE_PASSWORD:#{null}}
        truststore:
          location: ${REDIS_SSL_TRUSTSTORE:/etc/ssl/certs/truststore.jks}
          password: ${REDIS_SSL_TRUSTSTORE_PASSWORD:changeit}
      lettuce:
        pool:
          max-active: 50
          max-idle: 20
          min-idle: 10
          max-wait: 2000ms

  cache:
    type: redis
    redis:
      time-to-live: 300000
      cache-null-values: false

# Cache Invalidation Configuration
bss:
  cache:
    invalidation:
      enabled: true
      warming:
        enabled: true
        interval-minutes: 10
        hot-key-threshold: 20
      probabilistic-expiration:
        enabled: true
        base-probability: 0.1
        check-interval-seconds: 30
        max-entries-to-check: 1000
        hot-key-reduction-factor: 0.5
      postgres-notify:
        enabled: true
        channel-name: cache_invalidation
      redis-listener:
        enabled: true
        topics:
          - cache:invalidation:key
          - cache:invalidation:pattern
          - cache:invalidation:prefix

  session:
    store-type: redis
    redis:
      namespace: bss:session
      flush-mode: on_save
      timeout: 1800s
      repository:
        enabled: true

  threads:
    virtual:
      enabled: true
      # Virtual thread name pattern
      name-pattern: "bss-vt-${spring.application.name}-${System.properties['java.vm.name']}-${spring.profiles.active}-${0,number,0000}"

  # Reactor configuration
  reactor:
    # Netty worker threads
    netty:
      worker:
        thread:
          count: ${REACTOR_NETTY_WORKER_THREADS:0} # 0 = CPU cores * 2
    # Backpressure buffer size
    debug:
      agent:
        enabled: false # Enable only for debugging

  # WebFlux configuration for async/streaming
  webflux:
    codec:
      # Max in-memory size for multipart uploads
      max-in-memory-size: 10MB
      # Enable UUID encoding/decoding
      enable-uuid: true
    # HTTP/2 settings
    http2:
      enabled: ${SPRING_HTTP2_ENABLED:true}

  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI:http://localhost:8081/realms/bss}

  # Email configuration for notifications
  mail:
    host: ${SMTP_HOST:smtp.gmail.com}
    port: ${SMTP_PORT:587}
    username: ${SMTP_USERNAME:}
    password: ${SMTP_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

  # Kafka configuration for CloudEvents
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:kafka-1:9092,kafka-2:9092,kafka-3:9092}
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      acks: all
      retries: 3
      batch-size: 16384
      linger-ms: 5
      buffer-memory: 33554432
      properties:
        enable.idempotence: true
        max.in.flight.requests.per.connection: 1
        compression.type: snappy
        request.timeout.ms: 30000
        # SSL Configuration
        security.protocol: ${KAFKA_SSL_ENABLED:false}
        ssl.truststore.location: ${KAFKA_SSL_TRUSTSTORE_LOCATION:/etc/ssl/certs/truststore.jks}
        ssl.truststore.password: ${KAFKA_SSL_TRUSTSTORE_PASSWORD:changeit}
        ssl.keystore.location: ${KAFKA_SSL_KEYSTORE_LOCATION:/etc/ssl/certs/kafka/kafka.p12}
        ssl.keystore.password: ${KAFKA_SSL_KEYSTORE_PASSWORD:changeit}
        ssl.keystore.type: PKCS12
        ssl.client.auth: required
        ssl.enabled.protocols: TLSv1.2,TLSv1.3
        ssl.cipher.suites: TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP_ID:bss-backend}
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      auto-offset-reset: earliest
      enable-auto-commit: false
      properties:
        spring.json.trusted.packages: "com.droid.bss.domain.*"
        fetch.min.bytes: 1024
        fetch.max.wait.ms: 500
        max.partition.fetch.bytes: 1048576
        # SSL Configuration
        security.protocol: ${KAFKA_SSL_ENABLED:false}
        ssl.truststore.location: ${KAFKA_SSL_TRUSTSTORE_LOCATION:/etc/ssl/certs/truststore.jks}
        ssl.truststore.password: ${KAFKA_SSL_TRUSTSTORE_PASSWORD:changeit}
        ssl.keystore.location: ${KAFKA_SSL_KEYSTORE_LOCATION:/etc/ssl/certs/kafka/kafka.p12}
        ssl.keystore.password: ${KAFKA_SSL_KEYSTORE_PASSWORD:changeit}
        ssl.keystore.type: PKCS12
        ssl.client.auth: required
        ssl.enabled.protocols: TLSv1.2,TLSv1.3
        ssl.cipher.suites: TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    template:
      default-topic: ${KAFKA_DEFAULT_TOPIC:bss.events}
    listener:
      ack-mode: manual_immediate
      concurrency: 3

security:
  oauth2:
    audience: ${SPRING_SECURITY_OAUTH2_RESOURCESERVER_AUDIENCE:bss-backend}

# GraphQL Configuration
graphql:
  # Enable GraphQL Playground UI (development)
  playground:
    enabled: ${GRAPHQL_PLAYGROUND_ENABLED:true}
  # GraphQL endpoint
  path: /graphql
  # GraphiQL endpoint (for development)
  graphiql:
    enabled: ${GRAPHIQL_ENABLED:true}
  # Subscription settings with backpressure
  subscriptions:
    enabled: ${GRAPHQL_SUBSCRIPTIONS_ENABLED:true}
    # Subscription heartbeat interval
    heartbeat-interval: 30s
    # Max subscription duration
    max-subscription-duration: 1h
    # Backpressure settings
    backpressure:
      buffer-size: 1000
      rate-limit-per-second: 50
      batch-size: 10
      timeout: 5s
  # Exception handling
  exception-handlers:
    enabled: true
  # CORS settings
  cors:
    allowed-origins: ${GRAPHQL_CORS_ALLOWED_ORIGINS:*}
    allowed-methods: ${GRAPHQL_CORS_ALLOWED_METHODS:GET,POST,OPTIONS}
    allowed-headers: ${GRAPHQL_CORS_ALLOWED_HEADERS:*,Content-Type,Authorization}
    allow-credentials: ${GRAPHQL_CORS_CREDENTIALS:true}
  # Schema configuration
  schema:
    # Location of schema files
    locations: classpath:/graphql/
    # File extensions
    extensions: .graphql,.graphqls
  # Query depth limiting (DoS prevention)
  security:
    query-depth-limit: 10
    max-query-complexity: 1000

# RSocket Configuration
rsocket:
  # Server port
  port: ${RSOCKET_PORT:7000}
  # Transport type (tcp, websocket, Aeron)
  transport: tcp
  # Connection settings
  connection:
    # Keep-alive interval
    keep-alive-interval: 20s
    # Keep-alive timeout
    keep-alive-timeout: 15s
    # Session duration for resume
    session-duration: 5m
    # Stream timeout
    stream-timeout: 30s
  # Backpressure configuration
  backpressure:
    # Buffer size for event streams
    event-stream-buffer: 1000
    # Rate limit per second
    event-rate-limit: 50
    # Broadcast batch size
    broadcast-batch-size: 10
    # Broadcast backpressure buffer
    broadcast-buffer: 50
    # Connection timeout
    connection-timeout: 5s
    # Max concurrent broadcasts
    max-concurrent-broadcasts: 1
  # Client connection registry (Redis-backed)
  registry:
    type: redis
    cleanup-interval: 5m
    stale-connection-timeout: 10m
    max-local-connections: 1000
  # SSL/TLS settings
  ssl:
    enabled: ${RSOCKET_SSL_ENABLED:false}
    key-store: ${RSOCKET_KEYSTORE:#{null}}
    key-store-password: ${RSOCKET_KEYSTORE_PASSWORD:#{null}}
    key-store-type: ${RSOCKET_KEYSTORE_TYPE:PKCS12}
    trust-store: ${RSOCKET_TRUSTSTORE:#{null}}
    trust-store-password: ${RSOCKET_TRUSTSTORE_PASSWORD:#{null}}
  # Monitoring
  metrics:
    enabled: true
    connection-count-metric: rsocket.connections.count
    message-rate-metric: rsocket.messages.rate

management:
  endpoints:
    web:
      base-path: /actuator
      exposure:
        include: health,info,metrics,prometheus,rsocket,graphql
  endpoint:
    health:
      probes:
        enabled: true
      show-details: always
      show-components: always
    prometheus:
      enabled: true
    rsocket:
      enabled: true
      cache-duration: 30s
    graphql:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
        # Enable OpenMetrics format
        open-metrics:
          enabled: true
    distribution:
      percentiles-histogram:
        http.server.requests: true
        graphql: true
        rsocket: true
      sla:
        http.server.requests: 5ms,10ms,20ms,50ms,100ms,200ms,500ms,1s,2s,5s
        graphql.query: 10ms,50ms,100ms,200ms,500ms,1s
        rsocket.message: 1ms,5ms,10ms,50ms,100ms,500ms
    tags:
      application: ${spring.application.name}
      instance: ${INSTANCE_ID:${HOSTNAME}}
  tracing:
    sampling:
      probability: 1.0
    span:
      # Enable specific span attributes
      attributes:
        - http.method
        - http.status_code
        - graphql.operation.type
        - graphql.operation.name
        - rsocket.connection.id
        - message.type
  otlp:
    tracing:
      endpoint: ${OTEL_EXPORTER_OTLP_TRACES_ENDPOINT:http://localhost:4318/v1/traces}
    metrics:
      endpoint: ${OTEL_EXPORTER_OTLP_METRICS_ENDPOINT:http://localhost:4318/v1/metrics}
  # Observability configuration
  observations:
    # Enable specific observations
    key-values:
      service.name: ${spring.application.name}
      service.version: ${APP_VERSION:1.0.0}
      environment: ${SPRING_PROFILES_ACTIVE:dev}
    # Enable HTTP observations
    http:
      server:
        requests:
          enabled: true
    # Enable WebClient observations
    web:
      client:
        requests:
          enabled: true
    # Enable RSocket observations
    rsocket:
      client:
        connections: true
        messages: true
      server:
        connections: true
        messages: true
    # Enable GraphQL observations
    graphql:
      operations: true
      queries: true
      mutations: true
      subscriptions: true

# API Gateway Configuration
spring:
  cloud:
    gateway:
      # Global CORS settings
      globalcors:
        cors-configurations:
          '[/**]':
            allowed-origins: "*"
            allowed-methods: "*"
            allowed-headers: "*"
            allow-credentials: true
            max-age: 3600
      # HTTP client configuration
      httpclient:
        connect-timeout: 2000
        response-timeout: 5s
        pool:
          type: elastic
          max-connections: 50
          max-idle-connections: 1
          acquire-timeout: 30s
          eviction-interval: 30s
      # SSL configuration
      ssl:
        enabled: ${GATEWAY_SSL_ENABLED:false}
        key-password: ${GATEWAY_SSL_KEY_PASSWORD:changeit}
        key-store: ${GATEWAY_SSL_KEYSTORE:file:///etc/ssl/keystore.p12}
        key-store-password: ${GATEWAY_SSL_KEYSTORE_PASSWORD:changeit}
        key-store-type: ${GATEWAY_SSL_KEYSTORE_TYPE:PKCS12}
        trust-store: ${GATEWAY_SSL_TRUSTSTORE:file:///etc/ssl/truststore.jks}
        trust-store-password: ${GATEWAY_SSL_TRUSTSTORE_PASSWORD:changeit}
      # Default filters applied to all routes
      default-filters:
        # Remove hop-by-hop headers
        - RemoveRequestHeader=Cookie
        - RemoveRequestHeader=Upgrade
        - RemoveResponseHeader=Server
        # Add security headers
        - AddResponseHeader=X-Content-Type-Options, nosniff
        - AddResponseHeader=X-Frame-Options, DENY
        - AddResponseHeader=X-XSS-Protection, 1; mode=block
        # Add HSTS (only for HTTPS)
        - AddResponseHeader=Strict-Transport-Security, max-age=31536000; includeSubDomains; preload

# BSS Gateway Configuration
bss:
  gateway:
    # Rate limiting configuration
    rate-limit:
      default-rate: ${GATEWAY_RATE_LIMIT_DEFAULT:100}
      burst-capacity: ${GATEWAY_RATE_LIMIT_BURST:200}
      requested-tokens: ${GATEWAY_RATE_LIMIT_TOKENS:1000}
      enable-global-rate-limit: true
      global-rate-limit-key: ${GATEWAY_GLOBAL_RATE_LIMIT_KEY:global}
      request-timeout: ${GATEWAY_RATE_LIMIT_TIMEOUT:5}
    # Circuit breaker configuration
    circuit-breaker:
      enabled: ${GATEWAY_CIRCUIT_BREAKER_ENABLED:true}
      failure-rate-threshold: ${GATEWAY_CB_FAILURE_RATE:50}
      wait-duration-in-open-state: ${GATEWAY_CB_WAIT_DURATION:30}
      sliding-window-size: ${GATEWAY_CB_WINDOW_SIZE:10}
      minimum-number-of-calls: ${GATEWAY_CB_MIN_CALLS:5}
      slow-call-duration-threshold: ${GATEWAY_CB_SLOW_DURATION:2}
      slow-call-rate-threshold: ${GATEWAY_CB_SLOW_RATE:100}
      record-failure-exception: true
    # Load balancer configuration
    load-balancer:
      strategy: ${GATEWAY_LB_STRATEGY:round-robin}
      max-retries: ${GATEWAY_LB_MAX_RETRIES:3}
      connect-timeout: ${GATEWAY_LB_CONNECT_TIMEOUT:2000}
      read-timeout: ${GATEWAY_LB_READ_TIMEOUT:5000}
      retry-attempts: ${GATEWAY_LB_RETRY_ATTEMPTS:3}
      retry-delay: ${GATEWAY_LB_RETRY_DELAY:200}
    # Security configuration
    security:
      enable-jwt-validation: ${GATEWAY_JWT_VALIDATION:true}
      enable-rate-limiting: ${GATEWAY_RATE_LIMITING:true}
      enable-cors: ${GATEWAY_CORS:true}
      enable-https-redirect: ${GATEWAY_HTTPS_REDIRECT:false}
      enable-security-headers: ${GATEWAY_SECURITY_HEADERS:true}
      allowed-origins: ${GATEWAY_ALLOWED_ORIGINS:*}
      allowed-methods: ${GATEWAY_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS,PATCH}
      allowed-headers: ${GATEWAY_ALLOWED_HEADERS:*}
      max-age: ${GATEWAY_CORS_MAX_AGE:3600}
    # Monitoring configuration
    monitoring:
      enable-metrics: ${GATEWAY_METRICS:true}
      enable-tracing: ${GATEWAY_TRACING:true}
      enable-logging: ${GATEWAY_LOGGING:true}
      metrics-prefix: ${GATEWAY_METRICS_PREFIX:bss.gateway}
      log-level: ${GATEWAY_LOG_LEVEL:1}

# Service Discovery Configuration (Consul)
spring:
  cloud:
    consul:
      # Enable Consul service discovery
      enabled: ${CONSUL_ENABLED:true}
      # Consul server configuration
      host: ${CONSUL_HOST:localhost}
      port: ${CONSUL_PORT:8500}
      # Service discovery configuration
      discovery:
        # Service name
        service-name: ${CONSUL_SERVICE_NAME:bss-backend}
        # Service instance ID
        instance-id: ${CONSUL_INSTANCE_ID:${spring.application.name}-${server.port}-${random.value}}
        # Service port
        port: ${CONSUL_SERVICE_PORT:8080}
        # Enable health checks
        health-check: ${CONSUL_HEALTH_CHECK:true}
        # Health check interval
        health-check-interval: ${CONSUL_HEALTH_CHECK_INTERVAL:10s}
        # Health check timeout
        health-check-timeout: ${CONSUL_HEALTH_CHECK_TIMEOUT:5s}
        # Health check URL
        health-check-url: ${CONSUL_HEALTH_CHECK_URL:/actuator/health}
        # Heartbeat configuration
        heartbeat:
          enabled: ${CONSUL_HEARTBEAT_ENABLED:true}
          interval: ${CONSUL_HEARTBEAT_INTERVAL:5s}
        # Tags
        tags: ${CONSUL_TAGS:bss,backend,api,v1}
        # Metadata
        metadata:
          version: ${APP_VERSION:1.0.0}
          environment: ${SPRING_PROFILES_ACTIVE:dev}
          component: backend
        # Deregister critical services
        deregister: ${CONSUL_DEREGISTER:true}
        deregister-critical-service-after: ${CONSUL_DEREGISTER_AFTER:1m}
        # Prefer IP address
        prefer-ip-address: ${CONSUL_PREFER_IP:false}
        # Use hostname
        use-name-as-id: ${CONSUL_USE_NAME_AS_ID:false}
        # IP address to register
        ip-address: ${CONSUL_IP_ADDRESS:#{null}}
        # Hostname to register
        hostname: ${CONSUL_HOSTNAME:#{null}}
        # Datacenter
        datacenter: ${CONSUL_DATACENTER:#{null}}
        # Namespace
        namespace: ${CONSUL_NAMESPACE:#{null}}
      # Configuration service
      config:
        enabled: ${CONSUL_CONFIG_ENABLED:false}
        format: ${CONSUL_CONFIG_FORMAT:yaml}
        data-key: ${CONSUL_CONFIG_DATA_KEY:config}
        prefix: ${CONSUL_CONFIG_PREFIX:config}
        default-context: ${CONSUL_CONFIG_DEFAULT_CONTEXT:${spring.application.name}}
        profile-separator: ${CONSUL_CONFIG_PROFILE_SEPARATOR:,}
      # ACL token for Consul
      acl-token: ${CONSUL_ACL_TOKEN:#{null}}
      # Consistency mode
      consistency-mode: ${CONSUL_CONSISTENCY_MODE:default}
      # Time to wait before timing out
      time-to-live: ${CONSUL_TTL:30s}
      # Refresh configuration on change
      refreshable: ${CONSUL_REFRESHABLE:true}

# BSS Service Discovery Configuration
bss:
  servicediscovery:
    # Enable service discovery
    enabled: ${SERVICE_DISCOVERY_ENABLED:true}
    # Consul server host
    host: ${CONSUL_HOST:localhost}
    # Consul server port
    port: ${CONSUL_PORT:8500}
    # Service name
    service-name: ${CONSUL_SERVICE_NAME:bss-backend}
    # Service ID (auto-generated if not set)
    service-id: ${CONSUL_INSTANCE_ID:#{null}}
    # Service port
    service-port: ${CONSUL_SERVICE_PORT:8080}
    # Service tags
    tags: ${CONSUL_TAGS:bss,backend,api}
    # Enable health checks
    enable-health-check: ${CONSUL_HEALTH_CHECK_ENABLED:true}
    # Health check interval
    health-check-interval: ${CONSUL_HEALTH_CHECK_INTERVAL:10s}
    # Health check timeout
    health-check-timeout: ${CONSUL_HEALTH_CHECK_TIMEOUT:5s}
    # Health check path
    health-check-path: ${CONSUL_HEALTH_CHECK_PATH:/actuator/health}
    # Enable heartbeat
    enable-heartbeat: ${CONSUL_HEARTBEAT_ENABLED:true}
    # Heartbeat interval
    heartbeat-interval: ${CONSUL_HEARTBEAT_INTERVAL:5s}
    # Deregister critical service after
    deregister-critical-service-after: ${CONSUL_DEREGISTER_AFTER:1m}
    # Namespace (Consul Enterprise)
    namespace: ${CONSUL_NAMESPACE:#{null}}
    # Datacenter
    datacenter: ${CONSUL_DATACENTER:#{null}}

server:
  forward-headers-strategy: native
  tomcat:
    remoteip:
      protocol-header: X-Forwarded-Proto
      remote-ip-header: X-Forwarded-For
      host-header: X-Forwarded-Host

# Resilience4j Configuration
resilience4j:
  circuitbreaker:
    instances:
      backendService:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        sliding-window-size: 10
        minimum-number-of-calls: 5
        slow-call-rate-threshold: 100
        slow-call-duration-threshold: 2s
        automatic-transition-from-open-to-half-open-enabled: true
        events:
          enable-emit-after-state-transition: true
      customerQueryService:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        sliding-window-size: 10
        minimum-number-of-calls: 5
        slow-call-rate-threshold: 100
        slow-call-duration-threshold: 2s
        automatic-transition-from-open-to-half-open-enabled: true
        events:
          enable-emit-after-state-transition: true
      orderQueryService:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        sliding-window-size: 10
        minimum-number-of-calls: 5
        slow-call-rate-threshold: 100
        slow-call-duration-threshold: 2s
        automatic-transition-from-open-to-half-open-enabled: true
        events:
          enable-emit-after-state-transition: true
    metrics:
      legacy:
        enabled: true
  retry:
    instances:
      backendService:
        max-attempts: 3
        wait-duration: 1s
        retry-exceptions:
          - org.springframework.web.client.HttpServerErrorException
          - java.io.IOException
      customerQueryService:
        max-attempts: 3
        wait-duration: 1s
        retry-exceptions:
          - java.sql.SQLException
          - org.springframework.jdbc.CannotGetJdbcConnectionException
      orderQueryService:
        max-attempts: 3
        wait-duration: 1s
        retry-exceptions:
          - java.sql.SQLException
          - org.springframework.jdbc.CannotGetJdbcConnectionException
  timelimiter:
    instances:
      backendService:
        timeout-duration: 5s
      customerQueryService:
        timeout-duration: 3s
      orderQueryService:
        timeout-duration: 3s
  ratelimiter:
    instances:
      backendService:
        limit-for-period: 50
        limit-refresh-period: 10s
        timeout-duration: 0s
        allow-health-indicator-to-exceed-limits: true
      customerQueryService:
        limit-for-period: 100
        limit-refresh-period: 10s
        timeout-duration: 0s
        allow-health-indicator-to-exceed-limits: true
      orderQueryService:
        limit-for-period: 100
        limit-refresh-period: 10s
        timeout-duration: 0s
        allow-health-indicator-to-exceed-limits: true

      port-header: X-Forwarded-Port
      internal-proxies: 127\.0\.0\.1|::1|10\.(\d{1,3}\.){2}\d{1,3}|172\.(1[6-9]|2[0-9]|3[0-1])\.(\d{1,3}\.)\d{1,3}|192\.168\.(\d{1,3}\.)\d{1,3}

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha
    filter: true
    display-request-duration: true
    show-extensions: true
    show-common-extensions: true
  packages-to-scan: com.droid.bss.api
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
